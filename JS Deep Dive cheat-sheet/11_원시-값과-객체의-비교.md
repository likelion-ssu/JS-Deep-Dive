# 11. 원시 값과 객체의 비교
자바스크립트가 제공하는 7가지 데이터 타입에는 `숫자`, `문자`, `불리언`, `null`, `undefined`, `심벌`, `객체타입`이 있다.   
→ **원시 타입**(primitive type) & **객체 타입**(objective type)으로 구분 가능   

- **원시 타입과 객체 타입의 차이**

||**원시 타입**|**객체 타입**|
|:---:|---|---|
|**값의 가변성**|원시 값 : 변경 **불가능**한 값<br>(원시 값 : 원시 타입의 값)|객체 : 변경 **가능**한 값<br>(객체 : 객체(참조) 타입의 값)|
|**저장되는 값**|원시 값을 변수에 할당할 경우,<br>변수(할당된 메모리 공간)에는 **실제 값** 저장|객체를 변수에 할당할 경우,<br>변수(할당된 메모리 공간)에는 **참조 값** 저장|
|**값의 다른 변수로의 할당**|원시 값을 갖는 변수를 다른 변수에 할당할 경우,<br>원본의 **원시 값이 복사되어 전달**됨<br>**값에 의한 전달**|객체를 가리키는 변수를 다른 변수에 할당할 경우,<br>원본의 **참조 값이 복사되어 전달**됨<br>**참조에 의한 전달**|

## 📌 11.1 원시 값
### ▶️ 변경 불가능한 값
**원시 타입의 값**, 즉 **원시 값**은 **변경 불가능**한 값이다.   
→ 한 번 생성된 원시 값은 _읽기 전용(read only)값_ 이기에 변경할 수 없다.   

_값을 변경할 수 없음_ 의 의미는?   
**변수**와 **값**은 구분하여 생각해야 한다.    
- `변수` : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- `값` : 변수에 저장된 데이터, 표현식이 평가되어 생성된 결과   
`변경 불가능하다` : 변수가 아닌 **값에 대한 진술**   
→ "원시 값은 변경 불가능하다" : **원시 값 자체를 변경할 수 없음**을 의미할 뿐, **변수 값을 변경할 수 없다**는 의미는 아니다.   
→ `변수` : 언제든 **재할당**을 통해 변수 값을 변경(교체)할 수 있다.   

변수의 상대 개념 : `상수` → 재할당이 금지된 변수   
상수 역시 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.  
변수와의 차이는 `상수`는 **단 한 번만 할당이 허용**되므로 변수 값을 변경(교체)할 수 없다는 점이다.   
→ `상수`와 `변경 불가능한 값`을 동일시하는 것은 옳지 않다.   
→ `상수` : **재할당이 금지된 변수**일 뿐   

```js
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```
원시 값은 변경 불가능한 값, 즉 **읽기 전용의 값**이므로 어떤 일이 있어도 **불변**한다.   
원시 값의 특성은 **데이터의 신뢰성을 보장**한다는 것이다.  

원시 값을 할당한 변수에 새로운 원시 값을 재할당할 경우,   
❌ ~~메모리 공간에 저장되어 있는 재할당 이전의 원시 값 변경~~   
⭕️ **새로운 메모리 공간을 확보**하고 **재할당한 원시 값을 저장**한 후, **변수가 새롭게 재할당한 원시 값을 가리킨다**.  
→ 변수가 **참조하던 메모리 공간의 주소가 바뀐다**.   

<img src="https://user-images.githubusercontent.com/66112716/213905411-9f069949-ef9f-4337-9cb6-903dad6eeb97.png" width="600" />

변수가 참조하던 메모리 공간의 주소가 변경되는 이유 : **변수에 할당된 원시 값이 변경 불가능한 값이기 때문**    
변수 값을 변경하기 위해 **원시 값을 재할당**할 경우 아래와 같은 순서로 재할당된다.     
1. 새로운 메모리 공간을 확보한다.  
2. 재할당한 값을 저장한다.   
3. 변수가 참조하던 메모리 공간의 주소를 변경한다.   

→ 값의 이러한 특성 : **불변성**(immutability)   
**불변성을 가지는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**   

### ▶️ 문자열과 불변성
- 문자열 : 0개 이상의 문자로 이뤄진 집합, 1개의 문자는 2bytes의 메모리 공간에 저장
```js
// 문자열은 0개 이상의 문자들로 이뤄진 집합이다.
var str1 = '';      // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2 = 'Hello'; // 5개의 문자로 이뤄진 문자열
```

자바스크립트는 원시 타입인 **문자열 타입**을 제공한다.   
자바스크립트의 문자열은 **원시 타입**이며, **변경 불가능**하다.   
```js
var str = 'Hello';
str = 'world';
```
- 첫 번째 문의 실행
    - 문자열 `'Hello'` 생성
    - 식별자 `str` : 문자열 `'Hello'`가 저장된 메모리 공간의 첫 번째 메모리 셀 주소 가리킴
- 두 번째 문의 실행
    - 새로운 문자열 `'world'` 생성 (이전에 생성된 `'Hello'`를 수정하는 것 X)
    - 식별자 `str` : 새로 생겨난 문자열 `'world'` 가리킴   
→ `'Hello'`, `'world'`는 모두 메모리에 존재  
→ 식별자 `str` : 문자열 `'Hello'`를 가리키다가 `'world'`로 변경되었을 뿐   

문자열의 한 문자를 변경해 보자.   
문자열은 **유사 배열 객체**인 동시에 **이터러블**이므로 배열과 유사하게 각 문자에 접근할 수 있다.  
> **유사 배열 객체** : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 가지는 객체를 말한다.  
> 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있고, `length` 프로퍼티를 가지기에 유사 배열 객체이며,   
> for 문으로 순회 역시 가능하다.  
> 원시 값을 객체처럼 사용하면 원시 값을 감싸는 [래퍼 객체](https://developer-talk.tistory.com/69)로 자동 변환된다.   

```js
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = 'S';

console.log(str); // string
```

### ▶️ 값에 의한 전달
```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

score = 100;

console.log(score); // 100
console.log(copy);  // ?
```
위의 경우 `score` 변수에 새로운 숫자 값 100을 재할당하면, `copy` 변수의 값은 어떻게 될까?   
→ 질문의 핵심 : **"변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?"**   

변수에 원시 값을 갖는 변수를 할당할 경우,   
할당하는 변수(`copy`)에는 할당되는 변수(`score`)의 **원시 값이 복사**되어 전달된다.   
→ **값에 의한 전달**   
```js
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true
```
`score`와 `copy` 변수는 숫자 값 80을 가진다는 점에서는 동일하나,   
**`score` 변수와 `copy` 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.**   

<img src="https://user-images.githubusercontent.com/66112716/213906335-97985b17-7b34-40c4-bfb1-7aaebe80a47e.png" width="600" />

```js
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy);    // 80  80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy);    // 100  80
console.log(score === copy); // false
```

<img src="https://user-images.githubusercontent.com/66112716/213906447-8bb59d03-6414-4044-bfdb-151febe0681f.png" width="600" />

<img src="https://user-images.githubusercontent.com/66112716/213906458-b2febf40-e464-4beb-a866-b70f126d9edd.png" width="600" />

✨ **값에 의한 전달**은 두 가지 방식으로 해석될 수 있다.  
1. **값이 전달되는 것이 아니라 메모리 주소가 전달되는 것이다.**  
    - 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하고 있기 때문이다.
    - 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
2. **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이다.**  
    - 어느 한 쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없다.

## 📌 11.2 객체
- **객체의 특징**
    - 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가/삭제할 수 있다.   
    - 프로퍼티의 값에도 제약이 없다.   
    - 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.
- [자바스크립트 객체의 관리 방식](https://wooncloud.tistory.com/105)

### ▶️ 변경 가능한 값
**객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.**  
```js
var person = {
  name: 'Lee'
};
```
객체는 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**(reference value)에 접근할 수 있다.   
참조 값 : 생성된 **객체가 저장된 메모리 공간의 주소**, 그 자체   

<img src="https://user-images.githubusercontent.com/66112716/213906646-2876356e-d3c5-4152-bd67-1e2cad38f1e0.png" width="600" />

```js
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Lee"}
```
- **원시 값을 할당한 변수**
    - "변수는 @@@값을 갖는다." or "변수의 값은 @@@다."
- **객체를 할당한 변수**
    - "변수는 객체를 참조하고 있다." or "변수는 객체를 가리키고(Point) 있다."   
→ 위 예제의 `person` 변수는 객체 `{name : 'Lee'}`를 가리키고(참조하고) 있다.   

원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수 값을 변경하려면 재할당의 방법 밖에 없다.   
**객체**는 **변경 가능한 값**이다.   
따라서 **객체를 할당한 변수는 재할당 없이 객체를 직접 변경**할 수 있다.   
**재할당 없이 프로퍼티를 동적으로 추가**할 수 있고,   
**프로퍼티 값을 갱신**할 수 있으며, **프로퍼티 자체를 삭제**할 수도 있다.   

```js
var person = {
  name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';
// 프로퍼티 동적 생성
person.address = 'Seoul';
console.log(person); // {name: "Kim", address: "Seoul"}
```

- **객체 특징에 따른 성능 정리**
    - 객체의 생성 & 관리 방식은 매우 복잡하며 비용이 많이 든다.
        - 프로퍼티의 동적인 추가 및 갱신, 삭제가 가능하기 때문이다.
            - 프로퍼티 값이 객체일 수도 있다.
        - 메모리의 효율적 소비가 어렵고 성능이 나빠진다.
    - 메모리 효율적 사용을 위해, 객체 복사 비용 절약을 통한 성능 향상을 위해 객체는 **변경 가능한 값**으로 설계되었다.  
→ 구조적 단점에 따른 부작용 : **여러개의 식별자가 하나의 객체를 공유할 수 있다.**   

- [자바스크립트의 얕은 복사와 깊은 복사](https://velog.io/@th0566/Javascript-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC)
```js
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```
```js
const v = 1;

// "깊은 복사"라고 부르기도 한다.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// "얕은 복사"라고 부르기도 한다.
const c2 = o;
console.log(c2 === o); // true
```

### ▶️ 참조에 의한 전달
```js
var person = {
  name: 'Lee'
};

// 참조값을 복사(얕은 복사)
var copy = person;
```
객체를 가리키는 변수(원본, `person`)을 다른 변수(사본, `copy`)에 할당할 경우,   
원본의 **참조 값이 복사되어 전달**되며, 이를 **참조에 의한 전달**이라고 한다.   

<img src="https://user-images.githubusercontent.com/66112716/213907221-7023a4e7-d331-4510-abb3-9557d6ec9dc4.png" width="800" />

**여러개의 식별자가 하나의 객체를 공유**한다는 것은 어느 한 식별자를 통해 객체를 변경하였을 때,   
다른 식별자도 같은 객체를 참조하고 있기에 **서로 영향**을 받게 된다.   

```js
var person = {
  name: 'Lee'
};

// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```
- **값에 의한 전달**과 **참조에 의한 전달**
    - 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다는 점은 동일하다.
    - 식별자가 기억하는 메모리 공간(변수에 저장되어 있는 값)이 원시 값이냐, 참조 값이냐의 차이이다.   
→ 자바스크립트 : **참조에 의한 전달**은 **존재하지 않고**, **값에 의한 전달**만이 **존재**한다고 할 수 있다.   

### ⁉️ 퀴즈
다음 예제의 1번과 2번 콘솔에서 어떠한 값이 출력되는가?   
```js
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // ①
console.log(person1.name === person2.name); // ②
```
<details>
    <summary><b>💡 정답 & 해설 보기</b></summary>

`===` 연산자 : 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다.   
- 객체를 할당한 변수 : 참조 값을 가짐
- 원시 값을 할당한 변수 : 원시 값 자체를 가짐   

객체 리터럴은 평가 될 때마다 객체를 생성하므로,    
`person1`, `person2` 변수가 가리키는 객체는 내용은 같으나 다른 메모리에 저장된 별개의 객체이다.    
따라서 `person1`, `person2`의 참조 값은 다른 값이므로 1의 답은 `false`이다.   

프로퍼티 값을 참조하는 `person1.name`과 `person2.name`은 값으로 평가될 수 있는 표현식이다.   
두 표현식 모두 원시값 `Lee`로 평가되므로, 2는 `true`이다.   

</details>
